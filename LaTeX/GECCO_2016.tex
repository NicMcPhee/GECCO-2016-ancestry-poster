\documentclass{sig-alternate}

\usepackage{times}
\usepackage{url}
\usepackage{todonotes}
\sloppy

\setlength{\parindent}{0.5cm} 

\newcommand{\citep}[1]{\cite{#1}}

% Copyright
\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
\doi{10.475/123_4}

% ISBN
\isbn{123-4567-24-567/08/06}

\acmPrice{\$15.00}

% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

\begin{document}

\conferenceinfo{GECCO'16,} {July 20-24, 2016, Denver, Colorado, USA.}
\CopyrightYear{2016}
\crdata{TBA}
\clubpenalty=10000
\widowpenalty = 10000

\title{Visualizing genetic programming ancestries using graph databases}

%\numberofauthors{4}
%\author{
%\alignauthor
%Nicholas Freitag McPhee\\
%	\affaddr{Div. of Science and Math}\\
%	\affaddr{Univ. of Minnesota, Morris}\\
%	\affaddr{Morris, MN USA-56267}\\
%	\email{mcphee@morris.umn.edu}
%\alignauthor
%Maggie M. Casale\\
%	\affaddr{Div. of Science and Math}\\
%	\affaddr{Univ. of Minnesota, Morris}\\
%	\affaddr{Morris, MN USA-56267}\\
%	\email{casal033@morris.umn.edu}
%\and
%\alignauthor
%Mitchell Finzel \\
%	\affaddr{Div. of Science and Math}\\
%	\affaddr{Univ. of Minnesota, Morris}\\
%	\affaddr{Morris, MN USA-56267}\\
%	\email{finze008@morris.umn.edu}
%\and
%\alignauthor
%Thomas Helmuth\\
%	\affaddr{Computer Science Dep't}\\
%	\affaddr{Washington and Lee Univ.}\\
%	\affaddr{Lexington, VA USA-24450}\\
%	\email{helmutht@wlu.edu}
%\alignauthor
%Lee Spector\\
%	\affaddr{Cognitive Science}\\
%	\affaddr{Hampshire College}\\
%	\affaddr{Amherst, MA USA-01002}\\
%	\email{lspector@hampshire.edu}
%}

\maketitle

\begin{abstract}

Previous work has demonstrated the utility of graph databases as a tool for collecting and analyzing ancestry in evolutionary computation runs. That work focused on sections of individual runs, whereas this poster illustrates the application of these ideas on the entirety of large runs (up to one million individuals) and combinations of multiple runs.

Here we use these tools to generate graphs showing \emph{all} the ancestors of successful individuals from a variety of stack-based genetic programming runs on software synthesis problems. These graphs highlight important moments in the evolutionary process. They also allow us to compare the dynamics when using different evolutionary tools, such as different selection mechanisms or representations, as well as comparing the dynamics for successful and unsuccessful runs.

\end{abstract}

\begin{CCSXML}
	<ccs2012>
	<concept>
	<concept_id>10003120.10003145.10003146.10010892</concept_id>
	<concept_desc>Human-centered computing~Graph drawings</concept_desc>
	<concept_significance>500</concept_significance>
	</concept>
	<concept>
	<concept_id>10003120.10003145.10003147.10010364</concept_id>

	<concept_desc>Human-centered computing~Scientific visualization</concept_desc>
	<concept_significance>500</concept_significance>
	</concept>
	<concept>
	<concept_id>10010147.10010178.10010205.10010206</concept_id>
	<concept_desc>Computing methodologies~Heuristic function construction</concept_desc>
	<concept_significance>300</concept_significance>
	</concept>
	<concept>
	<concept_id>10010147.10010257.10010293.10011809.10011813</concept_id>
	<concept_desc>Computing methodologies~Genetic programming</concept_desc>
	<concept_significance>300</concept_significance>
	</concept>
	</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Human-centered computing~Graph drawings}
\ccsdesc[500]{Human-centered computing~Scientific visualization}
\ccsdesc[300]{Computing methodologies~Heuristic function construction}
\ccsdesc[300]{Computing methodologies~Genetic programming}

\printccsdesc

\keywords{visualization; genetic programming; graph database; ancestry}

\section{Introduction}
\label{sec:introduction}

\todo[inline]{This is quite short/thin because it's what we had on the poster paper.
We probably want to expand it now and improve the motivation.}

Reporting results of genetic programming (GP) and evolutionary computation is frequently limited to aggregate statistics such as mean best fitness or percentage of successful runs. Unfortunately this fails to convey the complex dynamics of such evolutionary systems and obscures or omits potentially valuable information about \emph{why} the runs behaved as they did. Previous work~\cite{McPhee:2015:GPTP} has demonstrated the utility of graph databases as tools for collecting and analyzing ancestry in GP runs, but was focused on sections of individual runs.

In this poster we illustrate the use of these tools as a means of exploring entire ancestry trees. We use the Titan graph database\footnote{\url{http://thinkaurelius.github.io/titan/}} along with the Gremlin shell and the Tinkerpop query tools\footnote{\url{https://tinkerpop.apache.org/}} to store the parent-child relationships from genetic programming runs, and to extract the ancestry trees of specified individuals. We then visualize these subgraphs using the Graphviz \texttt{dot} graph layout tool\footnote{\url{http://www.graphviz.org/}}.

\section{Our test environment: PushGP \& Replace Space With Newline}
\label{sec:testEnv}

All the visualizations presented here are on runs using the Clojush
implementation\footnote{\url{https://github.com/lspector/Clojush}} of the 
PushGP genetic programming (GP) system~\cite{spector:2002:GPEM, 1068292}, 
but all the ideas here
could easily apply to almost any evolutionary computation system. The use
of graph databases to capture ancestor lineage is a completely general
concept, for example, and could be applied to any system that implements a
notion of descent with modification. Some of the specifics of the visualization
are tied to particular metrics (e.g., the Damerau-Levenshtein distance
between Push program genomes), but these could be replaced with other
metrics as appropriate to the application domain (e.g., manhattan distances
between genetic algorithms bitstrings, or tree edit distances in
tree-based GP).

One important feature of the PushGP system is the use of \emph{lexicase
selection}~\cite{Helmuth:2015:ieeeTEC}. One of the goals in the design of
lexicase selection was the preservation of diversity of behaviors. The
ancestry information in the graph databases and in the tree visualizations 
in this paper can be used to visually and quantitatively check how
well those goals are being met. One property of lexicase selection is
that it enables the possibility of \emph{hyperselection} events~\cite{Helmuth:2016:GECCO},
where an individual receives an extremely high proportion of the selections
in a given generation. Occasionally, for example, an individual that
"discovers" an important new behavior can receive over 90\% of the selections
and consequently be a parent of nearly all the children in the next generation.
These hyperselection events will be visually obvious in our graph visualizations
below.

We have applied the visualizations described here on a 
number of different problems taken from a suite of software synthesis benchmark 
problems~\cite{Helmuth:2015:GECCO}, but in the interest of space we
will focus here on a single test problem: Replace Space With Newline.
In Replace Space With Newline the goal is to evolve a program that takes a string
as input and has two tasks: (a) it should print the input string, with all spaces
replaced by newlines, and (b) it should return an integer that is the number of
characters in the input string that were \emph{not} replaced. The use of
these two distinct types of error values will be used in some of the visualizations
as described in Section~\ref{sec:nodes}. The details of the system and
settings used in these runs are as described in~\cite{Helmuth:2015:GECCO}.

\section{Basic Structure}
\label{sec:basics}
These evolutionary computation runs are shown in the form of their ancestral trees. For a successful run, where at least one individual has found a solution to the problem, we get the ancestral tree by finding all individuals who have found a solution in the last generation. With these individuals, we go back through generations to grab their parents, grandparents, etc. until we have every ancestor of these individuals, up until the beginning generation. In an unsuccessful run, where no individual has found a solution to the problem, we get all of the individuals in the last generation (limited to 300 generations) and grab their ancestors to make the ancestral tree. 

Each ancestry tree diagram is composed of nodes and edges, where the nodes represent individuals and the edges represent their parent-child relationship. An example of this basic structure is in Figure \ref{fig:lexRun0Basic}. From this basic structure, we modify aspects of the edges and nodes such as color and size to show more information about individuals or relationships in each run.

\begin{figure*}
	\begin{center}
		\includegraphics[width=0.9\textwidth]{../Figures/run0_basic_structure.pdf}
	\end{center}
	\caption{Basic layout of successful ancestry trees, showing parent-child relationships. Generations are labeled on the left-hand side.}
	\label{fig:lexRun0Basic}
\end{figure*}

\section{Edges}
\label{sec:edges}

As stated previously, edges show the parent-child relationship in our ancestry diagrams. We've modified aspects of the edges such as color, style, width, and transparency to tell us more information about these runs. The color and style of an edge is based on what operator was used to create a child made. Here is the list of relations as \textbf{Style \& Color: Operator}.
\begin{itemize}
\setlength\itemsep{0em}
\item Solid \& Black: Alternation, followed by Uniform Mutation
\item Dashed \& Black: Alternation
\item Solid \& Orange: Uniform Mutation
\item Dashed \& Orange: Uniform Closed Mutation
\end{itemize}

The width of an edge is determined by the Damerau--Levenshtein distance between a parent's and child's genome~\cite{wiki:DLdist}. We use this as a measure to determine how similar a child is to its parent. The smaller the Damerau--Levenshtein distance, the more similar their genomes are. With edges, if a child is very similar its parent, the edge will be very wide. In converse, if a child is very different from its parent, the edge will be very slim.

The last aspect of edges is their transparency. We based this on the number of ancestry children an individual had. Meaning, an incoming edge is more opaque if the individual had many children in the current ancestry tree. This helps us find the parents of popular individuals since these edges are not as transparent as others.

\section{Nodes}
\label{sec:nodes}

Just as we adjust aspects of the edges in our diagrams to tell us more information about the runs, we adjust aspects of the nodes as well. These aspects include the width, height, and the color of the node. Our nodes are rectangle shaped for clarity and organization. 

The width of a node is based on the individual's number of selections. This is the number of times an individual was selected to have a child in the overall run, not just in the ancestry tree. One thing to note about this is that an individual can be both parents of a child, so in this scenario it would have two selections. A node that is very wide will have a overall high number of selections. This tells us that this individual was selected often or was ``hyperselected''~\cite{Helmuth:2016:GECCO}, so it could be interesting to know more about it. 

The height of a node is based on the individual's number of ancestry children. Similar to the opacity of an edge, a node is taller if it has many children in this ancestry tree. 

In the following graphs, we illustrate the use of two different coloring 
schemes for nodes, each of which conveys information about the errors 
(and thus the fitness) of the individuals represented by nodes. 
The first, \emph{dual coloring}, uses color to represent success on the 
two distinct types of errors (see Section~\ref{sec:testEnv}). The second,
\emph{RBM coloring}, uses restricted Boltzmann machines (RBMs) to compress
the 200 error values into three RGB color values.

The \emph{dual coloring} approach uses hue-saturation-lightness (HSL) coloring
based on the ``success'' of a given individual. 
The Replace Space With Newline problem is special in the sense that there are 
two halves of the problem, printing and returning. The test cases that track 
these aspects are also split into two sets of one-hundred cases. We take 
advantage of this by separating the two sets of cases and assigning a color 
to each half, with the color of the left side of a node based on the
printing errors, and the color on the right side based on the return errors.
For a test case to be passing, there needs to be an error of zero. 
The hue of one half of a node is based on the percent of zeros, i.e., 
successful cases, for that half. The hue 
ranges from red (the worst, with no zeros) to yellow (the best, with all zeros). 
This coloring tells us how many test cases an individual solves, but gives no 
information on how far off it is on the other test cases, so we incorporated 
lightness into the coloring as well. The lightness of one side of a node is 
based on the individual's total error on that half of the test cases, with 
higher total errors receiving darker shading.

One potential concern with the dual coloring approach is that we are simply 
counting successful test cases to determine the hue, and using the total
error for the lightness. Both of these are aggregate measures that can obscure
valuable details such as \emph{which} test cases are being solved. Because
lexicase selection bases selection on entire error vectors (instead of, for example,
just using total error), which test cases are being solved becomes much more
important than just how many, or what the total error is. To address this, we
generated a second coloring that used a simple 
implementation\footnote{\url{https://github.com/echen/restricted-boltzmann-machines}} 
of restricted Boltzmann machines (RBMs) as a dimensionality reduction 
tool~\cite{hinton2006reducing}. Here we trained RBM autoencoders to map 200-bit
vectors to 24-bit vectors, where the inputs were binary versions of the error
vectors where every non-zero value was converted to 1, and the outputs were
interpreted as 24-bit RGB colors. This allowed us to see valuable relationships
between individuals that were successful on similar sets of test cases.

\begin{figure*}
	\begin{center}
		\includegraphics[width=0.9\textwidth]{../Figures/run0_RBM_color_filtered_and_full_30000.pdf}
	\end{center}
	\caption{Unfiltered (left) and filtered (right) versions of a successful lexicase run, both with the same color map.}
	\label{fig:lexRun0FilteredAndFull}
\end{figure*}

\section{Filtering}
\label{sec:filtering}

While the large graphs of full runs can provide an excellent ``big picture'' 
view of the run dynamics, there is \emph{so} much information that it can be
difficult to isolate specific features. We can, however, extract and visualize
subgraphs that focus on specific areas or events in the runs.

One simple example of this sort of filtering that we've already introduced is
looking only at individuals that are in fact ancestors of individuals in the
final generation. Most individuals in evolutionary systems aren't ultimately
ancestors of individuals in the final population; they're evolutionary ``dead ends'',
either because they have no children, or their descendants eventually fail to have
children. All the graphs provided so far have used this filtering to substantially
cut down on the number of visualized nodes. This typically reduces the number of nodes in a
generation (row of the graph) from the original 1,000 to 300 or less, and sometimes down
to a few dozen.

\begin{figure*}[tb]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{../Figures/run1_RBM_color_filtered_and_full_60000.pdf}
	\end{center}
	\caption{Unfiltered (left) and filtered (right) versions of a successful lexicase run, both with the same color map.}
	\label{fig:lexRun1FilteredAndFull}
\end{figure*}


\section{Comparing runs}
\label{sec:comparisons}

% In this section we'll look at multiple successful runs in their filtered
% versions. We'll create a RBM color scheme which incorporates all error vectors
% in the filtered ancestries. This will allow us to see similar individual in 
% other runs. Ex) You may see red at the top of one run, and at the end of another. Which could imply that oine found a solution earlier.
\subsection{Successful Runs}
\begin{figure*}[tb]
	\begin{center}
		\includegraphics[height=0.95\textheight]{../Figures/runs_1_99_6_RBM_color_filtered2_with_space.pdf}
	\end{center}
	\caption{Filtered ancestry graphs of three successful runs (1, 99, and 6), all with the same color map.}
	\label{fig:runs1:99:6:filtered}
\end{figure*}

% In the section we'll look at least one successful and failed run in dual
% coloring. This will allow us to see how individuals are prgressing (or not)
% over time. Having these ancestries in full will allow us to generally comapre
% the generation sizes and get the visual impact of a failed run.

\subsection{Successful vs. Failed Runs}
%\begin{figure*}[tb]
%	\begin{center}
%		\includegraphics[width=0.5\textwidth]{../Figures/runs_92_2_dual_color_full_no_last_gen.pdf}
%	\end{center}
%	\caption{Full ancestry graphs of 2 failed runs (92 and 2), all with the same color map.}
%	\label{fig:runs92:2:filtered}
%\end{figure*}

%\begin{figure*}[tb]
%	\begin{center}
%		\includegraphics[width=0.5\textwidth]{../Figures/runs_92_2_1_99_dual_color_full_small.pdf}
%	\end{center}
%	\caption{Full ancestry graphs of 4 different runs (92, 2, 1, and 99), all with the same color map.}
%	\label{fig:runs92:2:1:99:filtered}
%\end{figure*}

\section{Future work}
\label{sec:futurework}
\todo[inline]{Autoconstruction, Dynamic views would be nice. Using google maps to visualize large graphs. Gephi. Centrality metrics. -Nic}

Lexicase vs. tournament!

In our RBM coloring we converted all our error vectors to binary vectors by
converting all non-zero values to 1. This obviously eliminates much potentially
valuable information. There are situations, for example, where an individual has
an error of 1 on a large group of test cases; such an individual is assigned
the same RBM color as an individual with an error of 1,000 on all those cases,
despite the fact that it's \emph{much} closer to the desired answer.
It would then be worth exploring alternatives that include
more, or perhaps, all the information in the error vector when generating the
colorings.

\todo[inline]{Look at previous VizGEC work. - Nic}


\bibliographystyle{abbrv}
\bibliography{GECCO_2016}

\end{document}